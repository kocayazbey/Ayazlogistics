# Kubernetes Admission Policies for AyazLogistics
# Enforces security constraints and image signing requirements

---
apiVersion: v1
kind: Namespace
metadata:
  name: gatekeeper-system
  labels:
    name: gatekeeper-system

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: gatekeeper-admin
  namespace: gatekeeper-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: gatekeeper-manager-role
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: gatekeeper-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gatekeeper-manager-role
subjects:
- kind: ServiceAccount
  name: gatekeeper-admin
  namespace: gatekeeper-system

---
## PSP removed: Using Pod Security Admission labels instead (see Namespace labels at bottom)

---
# Network Policy - Egress restrictions
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: ayazlogistics-network-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: ayazlogistics
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: production
    - podSelector:
        matchLabels:
          app: ayazlogistics
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: production
    - podSelector:
        matchLabels:
          app: ayazlogistics
  - to: []
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
  - to: []
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80

---
# OPA Gatekeeper Constraints
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        type: object
        properties:
          labels:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredlabels
        
        violation[{"msg": msg}] {
          required := input.parameters.labels
          provided := input.review.object.metadata.labels
          missing := required[_]
          not provided[missing]
          msg := sprintf("Missing required label: %v", [missing])
        }

---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sdisallowlatesttag
spec:
  crd:
    spec:
      names:
        kind: K8sDisallowLatestTag
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sdisallowlatesttag
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          endswith(container.image, ":latest")
          msg := sprintf("Using 'latest' tag is not allowed for image: %v", [container.image])
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: K8sDisallowLatestTag
metadata:
  name: disallow-latest-tag
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    namespaces: ["production"]

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: K8sRequiredLabels
metadata:
  name: must-have-labels
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    namespaces: ["production"]
  parameters:
    labels: ["app", "component", "version"]

---
# Image signature verification constraint
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredimage
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredImage
      validation:
        type: object
        properties:
          image:
            type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredimage
        
        violation[{"msg": msg}] {
          required := input.parameters.image
          provided := input.review.object.spec.containers[_].image
          not startswith(provided, required)
          msg := sprintf("Image must be from trusted registry: %v", [required])
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: K8sRequiredImage
metadata:
  name: must-use-trusted-registry
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    namespaces: ["production"]
  parameters:
    image: "ghcr.io/ayazlogistics/"

---
# Non-root user enforcement
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecuritycontext
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecurityContext
      validation:
        type: object
        properties:
          runAsNonRoot:
            type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecuritycontext
        
        violation[{"msg": msg}] {
          required := input.parameters.runAsNonRoot
          provided := input.review.object.spec.securityContext.runAsNonRoot
          required == true
          provided != true
          msg := "Container must run as non-root user"
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: K8sRequiredSecurityContext
metadata:
  name: must-run-as-non-root
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    namespaces: ["production"]
  parameters:
    runAsNonRoot: true

---
# Resource limits enforcement
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredresources
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredResources
      validation:
        type: object
        properties:
          limits:
            type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredresources
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.resources.limits
          msg := "Container must have resource limits defined"
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: K8sRequiredResources
metadata:
  name: must-have-resource-limits
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    namespaces: ["production"]
  parameters:
    limits: {}

---
# Cosign image signature verification
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredimageverification
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredImageVerification
      validation:
        type: object
        properties:
          publicKey:
            type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredimageverification
        
        violation[{"msg": msg}] {
          publicKey := input.parameters.publicKey
          image := input.review.object.spec.containers[_].image
          # This would integrate with Cosign for signature verification
          # For now, we'll check that images are from trusted registry
          not startswith(image, "ghcr.io/ayazlogistics/")
          msg := sprintf("Image must be signed and from trusted registry: %v", [image])
        }

---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: K8sRequiredImageVerification
metadata:
  name: must-have-signed-images
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    namespaces: ["production"]
  parameters:
    publicKey: "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----"

---
# Pod Security Standards enforcement
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
# Kyverno policies for additional security
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-non-root-user
spec:
  validationFailureAction: enforce
  background: true
  rules:
  - name: check-non-root
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Container must run as non-root user"
      pattern:
        spec:
          =(securityContext):
            =(runAsNonRoot): true
          containers:
          - =(securityContext):
              =(runAsNonRoot): true

---
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-resource-limits
spec:
  validationFailureAction: enforce
  background: true
  rules:
  - name: check-resource-limits
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Container must have resource limits"
      pattern:
        spec:
          containers:
          - =(resources):
              =(limits):
                =(memory): "?*"
                =(cpu): "?*"

---
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-privileged-containers
spec:
  validationFailureAction: enforce
  background: true
  rules:
  - name: check-privileged
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Privileged containers are not allowed"
      deny:
        conditions:
          any:
          - key: "{{ request.object.spec.containers[?privileged].privileged | length(@) }}"
            operator: GreaterThan
            value: 0

---
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-readonly-rootfs
spec:
  validationFailureAction: enforce
  background: true
  rules:
  - name: check-readonly-rootfs
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Container must have read-only root filesystem"
      pattern:
        spec:
          containers:
          - =(securityContext):
              =(readOnlyRootFilesystem): true

---
# Service Account token binding
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ayazlogistics
  namespace: production
  annotations:
    kubernetes.io/service-account.name: ayazlogistics
automountServiceAccountToken: false

---
# RBAC for service account
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ayazlogistics-role
  namespace: production
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ayazlogistics-rolebinding
  namespace: production
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ayazlogistics-role
subjects:
- kind: ServiceAccount
  name: ayazlogistics
  namespace: production
